<!DOCTYPE html>
<html lang="pt-br"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GA</title>
<meta name="keywords" content="Infosec, Security, Hacking">
<meta name="description" content="">
<meta name="author" content="Guilherme Assun√ß√£o Da Silva">
<link rel="canonical" href="https://guilherme30110.github.io/portfolio-web/">
<link rel="stylesheet" href="../assets/style.css">
<link rel="icon" href="https://www.brunorochamoura.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="C:\Users\Guilherme\Documents\icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="C:\Users\Guilherme\Documents\icon-33x32.png">
<link rel="apple-touch-icon" href="https://www.brunorochamoura.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.brunorochamoura.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="stylesheet" href="../assets//css/prism.css">



<!-- Linguagens extras (adicione s√≥ as que usar) -->
<script src="../assets/js/prism.js"></script>

<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<style>

pre[class*="language-"] {
  background: #282828;
  margin: 0;
  padding: 16px;
  border-radius: 8px;
  white-space: pre;
  word-break: normal;
  overflow-x: auto;
}

pre code {
  display: block !important;
  word-break: normal !important;
  white-space: pre !important;
  overflow-wrap: normal !important;
}

</style>
</head>
<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="#top" accesskey="h" title="GA (Alt + H)">GA</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://guilherme30110.github.io/portfolio-web/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://guilherme30110.github.io/portfolio-web/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://guilherme30110.github.io/portfolio-web/about" title="About">
                    <span>Sobre Mim</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <figure class="entry-cover">
     <img loading="eager"  srcset="https://media1.tenor.com/m/fZBFcgvtnmUAAAAd/ugotamail-hanx.gif 360w ,https://media1.tenor.com/m/fZBFcgvtnmUAAAAd/ugotamail-hanx.gif 480w ,https://media1.tenor.com/m/fZBFcgvtnmUAAAAd/ugotamail-hanx.gif 720w ,https://media1.tenor.com/m/fZBFcgvtnmUAAAAd/ugotamail-hanx.gif 800w" sizes="(min-width: 768px) 720px, 100vw" src="./index_files/cover.gif" alt="" width="800" height="350">
    </figure>
    <h1 class="post-title entry-hint-parent">
      Criando ferramenta de classifica√ß√£o de email
    </h1>
    <div class="post-meta"><span title="2025-05-15 00:00:00 +0000 UTC">May 15, 2025</span>&nbsp;¬∑&nbsp;2 min&nbsp;¬∑&nbsp;Guilherme Assun√ß√£o Da Silva

</div>
  </header> 
  <div class="post-content"><p>O e-mail continua sendo o principal ponto de entrada para amea√ßas digitais. De phishing sofisticado a malwares disfar√ßados de faturas, a carga de decidir o que √© seguro recai quase sempre sobre o usu√°rio final. 

    Para resolver esse problema com uma camada extra de intelig√™ncia, desenvolvi um script em Python que atua como um analista de seguran√ßa pessoal, monitorando a caixa de entrada e classificando o risco de cada mensagem instantaneamente. A ideia surgiu da necessidade de unir a agilidade da automa√ß√£o com o poder de discernimento dos modelos de linguagem modernos.
    Enquanto filtros de spam tradicionais baseiam-se em listas negras ou padr√µes r√≠gidos, minha ferramenta utiliza o modelo Gemma 2 para interpretar o contexto, a sem√¢ntica e a inten√ß√£o do remetente.

    <br></br>O uso do Ollama para rodar esse modelo localmente √© o cora√ß√£o do projeto: ele garante que nenhum dado sens√≠vel saia da m√°quina, mantendo a conformidade com boas pr√°ticas de seguran√ßa e privacidade.

    <br></br>O funcionamento t√©cnico √© fluido e estruturado em torno da biblioteca Imbox, que escuta o protocolo IMAP em tempo real. Quando um novo e-mail chega, o script realiza uma limpeza completa no conte√∫do usando BeautifulSoup para remover ru√≠dos de HTML e extrair apenas o que importa. 
    Esses dados s√£o ent√£o organizados em um banco de dados SQLite, garantindo que cada mensagem seja processada uma √∫nica vez e criando um hist√≥rico de an√°lises para futuras auditorias.

    <br></br>O grande diferencial est√° na Engenharia de Prompt. O script instrui a IA a agir estritamente como um analista de seguran√ßa, avaliando remetentes e links oficiais, mas mantendo a cautela para n√£o gerar falsos positivos em mensagens institucionais leg√≠timas. 
    O resultado √© entregue diretamente no terminal atrav√©s de um sistema de cores intuitivo: o verde para o que √© seguro, o amarelo para riscos baixos e o vermelho vibrante para alertas de alto risco.

<br></p>Implementar este projeto envolveu desafios interessantes de concorr√™ncia. Para garantir que a interface do usu√°rio n√£o travasse durante o processamento da IA, utilizei Multithreading para gerenciar um indicador visual de carregamento enquanto o Gemma 2 realiza a infer√™ncia em segundo plano. O resultado final √© uma ferramenta robusta, privada e extremamente √∫til para quem precisa de um "segundo olhar" t√©cnico antes de clicar em qualquer link suspeito.</p>

<hr>
<pre><code class="language-python">
from imbox import Imbox
from datetime import datetime, date, timedelta
from langchain_ollama import ChatOllama
from bs4 import BeautifulSoup
import sqlite3
from zoneinfo import ZoneInfo
from email.utils import parsedate_to_datetime
import itertools
import threading
import time
import sys

connection = sqlite3.connect("mails.db")
cursor = connection.cursor()

cursor.execute("CREATE TABLE IF NOT EXISTS emails (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, uid VARCHAR(20) UNIQUE, nome_remetente VARCHAR(255), assunto VARCHAR(255), remetente VARCHAR(255), corpo TEXT, date VARCHAR(20))")

# Conecta ao modelo local
llm = ChatOllama(model="gemma2")


host = 'imap.gmail.com'
# SEU EMAIL AQUI
email = ''
# Voc√™ deve criar uma senha de app aqui https://myaccount.google.com/apppasswords
# Coloque sua senha abaixo
password = 'cyjf cudk rtty cerm'
FUSO_BR = ZoneInfo("America/Sao_Paulo")


prompt = """
     Voc√™ √© um analista de seguran√ßa de e-mails. Use APENAS os campos fornecidos ‚Äî n√£o invente ou assuma qualquer outra informa√ß√£o.
     Dados:
      Nome do remetente: {}
      Assunto: {}
      Remetente: {}
      Corpo: {}
      Data: {}
    Classifique o risco do e-mail em UMA das quatro categorias: Seguro/Baixo/M√©dio/Alto.
     Instru√ß√µes:
      - Use somente os campos acima para decidir.
      - Pesquise se o remetente e links s√£o oficiais.
      - N√ÉO aumente o risco por causa de mensagens comuns em e-mails leg√≠timos, como:
  'n√£o responda este e-mail', 'procure o app', 'entre em contato pelo telefone', avisos autom√°ticos ou mensagens institucionais padronizadas.
      - N√£o use ‚Äúbaixo‚Äù para e-mails leg√≠timos, deve ser classificados como seguros. "Baixo" deve ser usado apenas quando h√° um detalhe m√≠nimo suspeito, mas n√£o forte o suficiente para indicar risco real.
      - N√£o marque como m√©dio ou alto se n√£o houver ind√≠cios claros no texto ou no remetente fornecidos.
      - Se estiver em d√∫vida, prefira uma classifica√ß√£o mais baixa (seguro/baixo).
      - Responda APENAS no formato exato abaixo (sem texto extra):
    Responda APENAS no formato:
      Nivel de Risco: <Seguro/Baixo/M√©dio/Alto>
      Motivo: <explique o motivo em 5 a 10 linhas>"""

def clear_line():
 sys.stdout.write("\r\033[K")
 sys.stdout.flush()

def spinner(msg, stop):
 for c in itertools.cycle(['‚†ã','‚†ô','‚†π','‚†∏','‚†º','‚†¥','‚†¶','‚†ß','‚†á','‚†è']):
  if stop.is_set():
   break
  sys.stdout.write(f"\r{msg['msg']} {c}")
  sys.stdout.flush()
  time.sleep(0.08)


msg = {"msg": "Novos emails aparecer√£o aqui"}
stop = threading.Event()


with Imbox(host, username=email, password=password) as imbox:
 print("________________________________________")
 select = str(input("Habilitar monitoramento da caixa de entrada de emails S/N: "))
 print("________________________________________")
 data_atual = datetime.now(FUSO_BR)
 if(select == "S" or select == "s"):
  threading.Thread(target=spinner,args=(msg, stop),daemon=True).start()
  while True:
   #messages = #
   for uid, message in imbox.messages(date__gt=data_atual, folder="INBOX", unread=True):
    date = message.date
    date = parsedate_to_datetime(date).astimezone(FUSO_BR)
    if(date >= data_atual + timedelta(seconds=1)):
     cursor.execute("SELECT * FROM emails WHERE uid = ?", (uid.decode(),))
     if cursor.fetchone():
      continue
     else:
      data_sistema = data_atual.strftime("%d/%m/%Y %H:%M:%S")
      date_brasil = date.strftime("%d/%m/%Y %H:%M:%S")
      body = message.body.get('html', [])
      plain_list = message.body.get('plain', [])
      if body:
       body = body[0]
      elif plain_list:
       body = plain_list[0]
      soup = BeautifulSoup(body, "html.parser")
      nome_remetente = message.sent_from[0]['name']
      remetente = message.sent_from[0]['email']
      assunto = message.subject
      body = " ".join(soup.get_text(separator=" ", strip=True).split())
      if isinstance(body, bytes):
       body = body.decode("utf-8", errors="ignore")
      cursor.execute("INSERT INTO emails (uid, nome_remetente, assunto, remetente, corpo, date) VALUES (?,?,?,?,?,?)", (uid.decode(), nome_remetente,assunto, remetente,body,date_brasil))
      clear_line()
      msg['msg'] = "Analisando email"
      res = llm.invoke(prompt.format(nome_remetente, assunto, remetente, body, date_brasil))
      content = res.content.strip()
      if "Nivel de Risco: Seguro" in content:
       content = content.replace("Seguro", "\033[32mSeguro\033[m")
       content = content.replace("Motivo:", "\033[32mMotivo:\033[m")
      elif "Nivel de Risco: Baixo" in content:
       content = content.replace("Baixo", "\033[33mBaixo\033[m")
       content = content.replace("Motivo:", "\033[33mMotivo:\033[m")
      elif "Nivel de Risco: M√©dio" in content:
       content = content.replace("M√©dio", "\033[38;5;208mM√©dio\033[m")
       content = content.replace("Motivo:", "\033[38;5;208mMotivo\033[m")
      elif "Nivel de Risco: Alto" in content:
       content = content.replace("Alto", "\033[31mAlto\033[m")
       content = content.replace("Motivo:", "\033[31mMotivo:\033[m")
     clear_line()
     print(content)
     msg['msg'] = "Novos emails aparecer√£o aqui"
   connection.commit()
</code></pre>


<p>O c√≥digo foi desenvolvido como um pipeline de seguran√ßa automatizado que integra comunica√ß√£o de rede, persist√™ncia de dados e intelig√™ncia artificial generativa. A execu√ß√£o inicia-se com a configura√ß√£o de um banco de dados SQLite, utilizado como uma camada de controle e auditoria. Atrav√©s da cria√ß√£o de uma tabela com a restri√ß√£o UNIQUE no campo uid, o script garante a integridade da opera√ß√£o, impedindo que o mesmo e-mail seja analisado m√∫ltiplas vezes, o que otimiza o uso de recursos e evita redund√¢ncias no hist√≥rico de alertas.
<br></br>A coleta de dados √© realizada pela biblioteca Imbox, que estabelece uma conex√£o com o servidor via protocolo IMAP. O script aplica um filtro temporal rigoroso, comparando o timestamp das mensagens com a hora de in√≠cio da execu√ß√£o. Isso permite que a ferramenta ignore o hist√≥rico antigo e foque exclusivamente no monitoramento reativo. Ao detectar uma nova mensagem, o sistema realiza um pr√©-processamento cr√≠tico utilizando a biblioteca BeautifulSoup. Esta etapa limpa o conte√∫do HTML, removendo ru√≠dos visuais e scripts, para entregar ao modelo de IA apenas o n√∫cleo sem√¢ntico do texto, garantindo que a an√°lise de risco seja baseada no conte√∫do real e na inten√ß√£o do remetente.
<br></br>O n√∫cleo anal√≠tico do projeto utiliza o Gemma 2, orquestrado atrav√©s da biblioteca LangChain. A l√≥gica de detec√ß√£o √© definida por um prompt estruturado que instrui a IA a atuar como um analista de seguran√ßa, avaliando o risco em quatro n√≠veis: Seguro, Baixo, M√©dio e Alto. Um diferencial importante na implementa√ß√£o √© o uso de Multithreading. Para evitar que a interface de linha de comando trave durante a infer√™ncia da IA ‚Äî que pode ser lenta em processamento via CPU ‚Äî, o script executa um indicador visual de carregamento (spinner) em uma thread separada, mantendo o usu√°rio informado sobre o progresso sem interromper o fluxo principal.
<br></br>Por fim, a sa√≠da de dados √© tratada para facilitar a interpreta√ß√£o imediata. O script processa a resposta da IA e aplica c√≥digos de escape ANSI para colorir as mensagens no terminal: verde para comunica√ß√µes seguras e vermelho vibrante para alertas cr√≠ticos. Mesmo diante de limita√ß√µes de hardware que impedem o processamento em lote ou a an√°lise massiva de reputa√ß√£o de dom√≠nios, a arquitetura atual foca na efici√™ncia e na privacidade, processando cada mensagem de forma isolada e local para garantir que nenhum dado sens√≠vel saia do ambiente controlado do usu√°rio.</p>

<hr>
  <footer class="post-footer">
    <ul class="post-tags">
     <li><a href="https://guilherme30110.github.io/portfolio-web/tags/cybersec">CyberSec üõ°Ô∏è</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <p><a href="https://creativecommons.org/publicdomain/zero/1.0/" style="color: white;">Nenhum direito reservado</a>. Use meus conte√∫dos livremente de sua pr√≥pria responsabilidade. Nenhuma permiss√£o √© necess√°ria, cr√©ditos s√£o bem-vindos.
    </p>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g" style="visibility: hidden; opacity: 0;">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z"></path>
    </svg>
</a>
<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body></html>
